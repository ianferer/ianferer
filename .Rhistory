r <- nb.fit$theta
p <- predict(nb.fit, data.frame(team = team, home = home), type = "response")
p <- r / (r + p)
r <- r/60
both.starters <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], as.numeric(x[7]),
as.numeric(x[9]) - as.numeric(x[7]),
A2, B2, p[2], as.numeric(x[6]),
as.numeric(x[8]) - as.numeric(x[6]),
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
home.backup <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], 0, 0,
A2, B2, p[2], as.numeric(x[6]),
as.numeric(x[8]) - as.numeric(x[6]),
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
away.backup <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], as.numeric(x[7]),
as.numeric(x[9]) - as.numeric(x[7]),
A2, B2, p[2], 0, 0,
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
both.backups <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], 0, 0,
A2, B2, p[2], 0, 0,
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
wp.recs <- tibble(eval.times,
both.starters = both.starters,
home.backup = home.backup,
away.backup = away.backup,
both.backups = both.backups) %>%
mutate(d.wp.home = home.backup - both.starters,
d.wp.away = (1 - away.backup) - (1 - both.starters),
home.rec = ifelse(d.wp.home > 0, "Pull", "Keep"),
away.rec = ifelse(d.wp.away > 0, "Pull", "Keep")) %>%
filter(time > 0 & time < 3600)
return(wp.recs)
}
rec.output <- function(wp.recs) {
# wp.recs = full data frame of recommendation information
# return smaller data frame that outputs necessary information
return(select(wp.recs,
home.team, away.team, time, home.goals, away.goals, both.starters,
d.wp.home, d.wp.away, home.rec, away.rec))
}
today.games <- fromJSON("https://statsapi.web.nhl.com/api/v1/schedule")
live.games <- data.frame(game_id = today.games[["dates"]][["games"]][[1]][["gamePk"]],
status = today.games[["dates"]][["games"]][[1]][["status"]][["detailedState"]]) %>%
filter(grepl("In Progress", status)) %>%
select(game_id) %>%
unlist()
game.link <- paste("https://statsapi.web.nhl.com/api/v1/game/",
live.games,
"/feed/live?site=en_nhl", sep = "")
g.json <- lapply(game.link, fromJSON)
eval.times <- lapply(g.json, get.eval.times)
# prior data
prior.shots <- filter(shot.data, season == 2020)
nb.fit <- glm.nb(shots ~ team + home, data = prior.shots)
svp <- prior.shots$st.svp.adj
beta.params <- beta.mom(mean(svp), var(svp))
beta.mle <- fitdistr(svp, "beta", start = list(shape1 = beta.params[1], shape2 = beta.params[2]),
lower = c(0, 0))
svp.A <- beta.mle$estimate[2]
svp.B <- beta.mle$estimate[1]
A1 <- svp.A
A2 <- svp.A
B1 <- svp.B
B2 <- svp.B
wp.recs <- lapply(eval.times, function(x) get.win.probs(x, nb.fit, A1, A2, B1, B2))
lapply(wp.recs, rec.output)
today.games$dates$games[[1]]$status$detailedState
# --------------------------------------------
# Live Evaluation (All Games)
# --------------------------------------------
# average win probabilities from models 2 and 4
# model 2 functions
s.prob.score.k <- function(k, A, B, r, p) {
# k = number of goals scored
# A, B = save percentage prior encoding
# r, p = negative binomial distribution parameters
m <- k:100
Q <- choose(m, k) * choose(m + r - 1, m) * (1/beta(A, B)) * beta(A + k, B + m - k) * (p^r) * ((1 - p)^m)
return(sum(Q))
}
s.win.prob.k <- function(k1, k2, A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d) {
# k1 = number of goals by home team
# k2 = number of goals by away team
# A1, B1 = save percentage prior encoding of home team
# p1 = NB prob. parameter of home team
# g1 = goals allowed by home team up to time t
# s1 = saves made by home team up to time t
# A2, B2 = save percentage prior encoding of away team
# p2 = NB prob. parameter of away team
# g2 = goals allowed by away team up to time t
# s2 = saves made by away team up to time t
# r = NB shape parameter estimate
# t = seconds remaining in regulation
# d = current score differential (from perspective of home team)
prob.adj <- ifelse(k1 - k2 > -d, 1, 1/2)
home.comp <- s.prob.score.k(k1, A2 + g2, B2 + s2, t*r, p1)
away.comp <- s.prob.score.k(k2, A1 + g1, B1 + s1, t*r, p2)
return(prob.adj * home.comp * away.comp)
}
s.win.prob.t <- function(A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d) {
# choose upper bound on K (K.max) by finding minimum n such that P(score at most n) >= 0.99
N <- seq(0, 100, by = 1)
prob.k1 <- sapply(N, function(x) s.prob.score.k(x, A2 + g2, B2 + s2, t*r, p1))
prob.k2 <- sapply(N, function(x) s.prob.score.k(x, A1 + g1, B1 + s1, t*r, p2))
c.prob.k1 <- sapply(1:length(prob.k1), function(x) sum(prob.k1[1:x]))
c.prob.k2 <- sapply(1:length(prob.k2), function(x) sum(prob.k2[1:x]))
K1.max <- N[min(which(c.prob.k1 >= 0.999))]
K2.max <- N[min(which(c.prob.k2 >= 0.999))]
K1 <- rep(seq(0, K1.max, by = 1), rep(K2.max + 1, K1.max + 1))
K2 <- rep(seq(0, K2.max, by = 1), K1.max + 1)
K <- cbind(K1, K2) %>% as.data.frame() %>% filter(K1 - K2 >= -d)
W <- apply(K, MARGIN = 1, function(x) s.win.prob.k(x[1], x[2], A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d))
return(sum(W))
}
# model 4 functions
g.prob.score.k <- function(k, L) {
# k = number of goals scored
# l = Poisson distribution parameter (goal-scoring rate)
return(dpois(k, L))
}
g.win.prob.k <- function(k1, k2, L1, L2, t, d) {
# k1 = number of goals by home team
# k2 = number of goals by away team
# L1 = Poisson parameter of home team
# L2 = Poisson parameter of away team
# t = seconds remaining in regulation
# d = current score differential (from perspective of home team)
prob.adj <- ifelse(k1 - k2 > -d, 1, 1/2)
home.comp <- g.prob.score.k(k1, L1 * t)
away.comp <- g.prob.score.k(k2, L2 * t)
return(prob.adj * home.comp * away.comp)
}
g.win.prob.t <- function(L1, L2, t, d) {
# choose upper bound on K (K.max) by finding minimum n such that P(score at most n) >= 0.99
N <- seq(0, 100, by = 1)
prob.k1 <- sapply(N, function(x) g.prob.score.k(x, L1 * t))
prob.k2 <- sapply(N, function(x) g.prob.score.k(x, L2 * t))
c.prob.k1 <- sapply(1:length(prob.k1), function(x) sum(prob.k1[1:x]))
c.prob.k2 <- sapply(1:length(prob.k2), function(x) sum(prob.k2[1:x]))
K1.max <- N[min(which(c.prob.k1 >= 0.999))]
K2.max <- N[min(which(c.prob.k2 >= 0.999))]
K1 <- rep(seq(0, K1.max, by = 1), rep(K2.max + 1, K1.max + 1))
K2 <- rep(seq(0, K2.max, by = 1), K1.max + 1)
K <- cbind(K1, K2) %>% as.data.frame() %>% filter(K1 - K2 >= -d)
W <- apply(K, MARGIN = 1, function(x) g.win.prob.k(x[1], x[2], L1, L2, t, d))
return(sum(W))
}
win.prob.t <- function(A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, L1, L2, t, r, d) {
s.prob <- s.win.prob.t(A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d)
g.prob <- g.win.prob.t(L1, L2, t, d)
w.prob <- ((1/3) * s.prob) + ((2/3) * g.prob)
return(w.prob)
}
team.replace <- function(team.code) {
# team.code = vector of 3-letter team codes
# return vector replacing LAK, NJD, SJS, and TBL with L.A, N.J, S.J, and T.B
new.code <- ifelse(team.code == "LAK", "L.A",
ifelse(team.code == "NJD", "N.J",
ifelse(team.code == "SJS", "S.J",
ifelse(team.code == "TBL", "T.B", team.code))))
return(new.code)
}
get.eval.times <- function(g.json) {
# g.json = JSON file for a given game
# return data frame of information at goalie evaluation times (period ends and all goals)
g.id <- g.json[["gameData"]][["game"]][["pk"]]
game.year <- g.id %/% (1e6)
game.id <- g.id %% (1e6)
h.team <- g.json[["gameData"]][["teams"]][["home"]][["triCode"]]
a.team <- g.json[["gameData"]][["teams"]][["away"]][["triCode"]]
e.times <- data.frame(season = season,
game_id = game.id,
home.team = h.team,
away.team = a.team,
team = g.json[["liveData"]][["plays"]][["allPlays"]][["team"]][["triCode"]],
event = g.json[["liveData"]][["plays"]][["allPlays"]][["result"]][["event"]],
goals = g.json[["liveData"]][["plays"]][["allPlays"]][["about"]][["goals"]],
period = g.json[["liveData"]][["plays"]][["allPlays"]][["about"]][["period"]],
time = g.json[["liveData"]][["plays"]][["allPlays"]][["about"]][["periodTimeRemaining"]])
eval.times <- e.times %>%
filter(event %in% c("Goal", "Shot", "Game Scheduled", "Period End")) %>%
filter(period <= 3) %>%
mutate(home.shot = as.numeric(event != "Game Scheduled" &
event != "Period End" &
as.character(team) == as.character(home.team)),
away.shot = as.numeric(event != "Game Scheduled" &
event != "Period End" &
as.character(team) == as.character(away.team)),
time = (60 * 20 * period) - as.numeric(seconds(ms(time)))) %>%
group_by(season, game_id, home.team, away.team) %>%
summarise(time = time,
event = event,
home.goals = goals.home,
away.goals = goals.away,
home.shots = cumsum(home.shot),
away.shots = cumsum(away.shot),
.groups = "drop") %>%
filter(event != "Shot") %>%
select(-event) %>%
mutate(d.score = home.goals - away.goals,
home.team = team.replace(as.character(home.team)),
away.team = team.replace(as.character(away.team)))
return(eval.times)
}
get.win.probs <- function(eval.times, nb.fit, A1, A2, B1, B2) {
# eval.times = data frame of goalie evaluation times for a single game
# nb.fit = negative binomial fit on today's prior shots
# A1, A2, B1, B2 = save probability information from today's prior shots
# return updated data frame for game with win probabilities
h.team <- unique(eval.times["home.team"])
a.team <- unique(eval.times["away.team"])
home <- c("Home", "Away")
team <- unname(unlist(c(h.team, a.team)))
r <- nb.fit$theta
p <- predict(nb.fit, data.frame(team = team, home = home), type = "response")
p <- r / (r + p)
r <- r/60
both.starters <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], as.numeric(x[7]),
as.numeric(x[9]) - as.numeric(x[7]),
A2, B2, p[2], as.numeric(x[6]),
as.numeric(x[8]) - as.numeric(x[6]),
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
home.backup <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], 0, 0,
A2, B2, p[2], as.numeric(x[6]),
as.numeric(x[8]) - as.numeric(x[6]),
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
away.backup <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], as.numeric(x[7]),
as.numeric(x[9]) - as.numeric(x[7]),
A2, B2, p[2], 0, 0,
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
both.backups <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], 0, 0,
A2, B2, p[2], 0, 0,
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
wp.recs <- tibble(eval.times,
both.starters = both.starters,
home.backup = home.backup,
away.backup = away.backup,
both.backups = both.backups) %>%
mutate(d.wp.home = home.backup - both.starters,
d.wp.away = (1 - away.backup) - (1 - both.starters),
home.rec = ifelse(d.wp.home > 0, "Pull", "Keep"),
away.rec = ifelse(d.wp.away > 0, "Pull", "Keep")) %>%
filter(time > 0 & time < 3600)
return(wp.recs)
}
rec.output <- function(wp.recs) {
# wp.recs = full data frame of recommendation information
# return smaller data frame that outputs necessary information
return(select(wp.recs,
home.team, away.team, time, home.goals, away.goals, both.starters,
d.wp.home, d.wp.away, home.rec, away.rec))
}
today.games <- fromJSON("https://statsapi.web.nhl.com/api/v1/schedule")
live.games <- data.frame(game_id = today.games[["dates"]][["games"]][[1]][["gamePk"]],
status = today.games[["dates"]][["games"]][[1]][["status"]][["detailedState"]]) %>%
filter(grepl("In Progress", status)) %>%
select(game_id) %>%
unlist()
game.link <- paste("https://statsapi.web.nhl.com/api/v1/game/",
live.games,
"/feed/live?site=en_nhl", sep = "")
g.json <- lapply(game.link, fromJSON)
eval.times <- lapply(g.json, get.eval.times)
# prior data
prior.shots <- filter(shot.data, season == 2020)
nb.fit <- glm.nb(shots ~ team + home, data = prior.shots)
svp <- prior.shots$st.svp.adj
beta.params <- beta.mom(mean(svp), var(svp))
beta.mle <- fitdistr(svp, "beta", start = list(shape1 = beta.params[1], shape2 = beta.params[2]),
lower = c(0, 0))
svp.A <- beta.mle$estimate[2]
svp.B <- beta.mle$estimate[1]
A1 <- svp.A
A2 <- svp.A
B1 <- svp.B
B2 <- svp.B
wp.recs <- lapply(eval.times, function(x) get.win.probs(x, nb.fit, A1, A2, B1, B2))
lapply(wp.recs, rec.output)
# --------------------------------------------
# Live Evaluation (All Games)
# --------------------------------------------
# average win probabilities from models 2 and 4
# model 2 functions
s.prob.score.k <- function(k, A, B, r, p) {
# k = number of goals scored
# A, B = save percentage prior encoding
# r, p = negative binomial distribution parameters
m <- k:100
Q <- choose(m, k) * choose(m + r - 1, m) * (1/beta(A, B)) * beta(A + k, B + m - k) * (p^r) * ((1 - p)^m)
return(sum(Q))
}
s.win.prob.k <- function(k1, k2, A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d) {
# k1 = number of goals by home team
# k2 = number of goals by away team
# A1, B1 = save percentage prior encoding of home team
# p1 = NB prob. parameter of home team
# g1 = goals allowed by home team up to time t
# s1 = saves made by home team up to time t
# A2, B2 = save percentage prior encoding of away team
# p2 = NB prob. parameter of away team
# g2 = goals allowed by away team up to time t
# s2 = saves made by away team up to time t
# r = NB shape parameter estimate
# t = seconds remaining in regulation
# d = current score differential (from perspective of home team)
prob.adj <- ifelse(k1 - k2 > -d, 1, 1/2)
home.comp <- s.prob.score.k(k1, A2 + g2, B2 + s2, t*r, p1)
away.comp <- s.prob.score.k(k2, A1 + g1, B1 + s1, t*r, p2)
return(prob.adj * home.comp * away.comp)
}
s.win.prob.t <- function(A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d) {
# choose upper bound on K (K.max) by finding minimum n such that P(score at most n) >= 0.99
N <- seq(0, 100, by = 1)
prob.k1 <- sapply(N, function(x) s.prob.score.k(x, A2 + g2, B2 + s2, t*r, p1))
prob.k2 <- sapply(N, function(x) s.prob.score.k(x, A1 + g1, B1 + s1, t*r, p2))
c.prob.k1 <- sapply(1:length(prob.k1), function(x) sum(prob.k1[1:x]))
c.prob.k2 <- sapply(1:length(prob.k2), function(x) sum(prob.k2[1:x]))
K1.max <- N[min(which(c.prob.k1 >= 0.999))]
K2.max <- N[min(which(c.prob.k2 >= 0.999))]
K1 <- rep(seq(0, K1.max, by = 1), rep(K2.max + 1, K1.max + 1))
K2 <- rep(seq(0, K2.max, by = 1), K1.max + 1)
K <- cbind(K1, K2) %>% as.data.frame() %>% filter(K1 - K2 >= -d)
W <- apply(K, MARGIN = 1, function(x) s.win.prob.k(x[1], x[2], A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d))
return(sum(W))
}
# model 4 functions
g.prob.score.k <- function(k, L) {
# k = number of goals scored
# l = Poisson distribution parameter (goal-scoring rate)
return(dpois(k, L))
}
g.win.prob.k <- function(k1, k2, L1, L2, t, d) {
# k1 = number of goals by home team
# k2 = number of goals by away team
# L1 = Poisson parameter of home team
# L2 = Poisson parameter of away team
# t = seconds remaining in regulation
# d = current score differential (from perspective of home team)
prob.adj <- ifelse(k1 - k2 > -d, 1, 1/2)
home.comp <- g.prob.score.k(k1, L1 * t)
away.comp <- g.prob.score.k(k2, L2 * t)
return(prob.adj * home.comp * away.comp)
}
g.win.prob.t <- function(L1, L2, t, d) {
# choose upper bound on K (K.max) by finding minimum n such that P(score at most n) >= 0.99
N <- seq(0, 100, by = 1)
prob.k1 <- sapply(N, function(x) g.prob.score.k(x, L1 * t))
prob.k2 <- sapply(N, function(x) g.prob.score.k(x, L2 * t))
c.prob.k1 <- sapply(1:length(prob.k1), function(x) sum(prob.k1[1:x]))
c.prob.k2 <- sapply(1:length(prob.k2), function(x) sum(prob.k2[1:x]))
K1.max <- N[min(which(c.prob.k1 >= 0.999))]
K2.max <- N[min(which(c.prob.k2 >= 0.999))]
K1 <- rep(seq(0, K1.max, by = 1), rep(K2.max + 1, K1.max + 1))
K2 <- rep(seq(0, K2.max, by = 1), K1.max + 1)
K <- cbind(K1, K2) %>% as.data.frame() %>% filter(K1 - K2 >= -d)
W <- apply(K, MARGIN = 1, function(x) g.win.prob.k(x[1], x[2], L1, L2, t, d))
return(sum(W))
}
win.prob.t <- function(A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, L1, L2, t, r, d) {
s.prob <- s.win.prob.t(A1, B1, p1, g1, s1, A2, B2, p2, g2, s2, t, r, d)
g.prob <- g.win.prob.t(L1, L2, t, d)
w.prob <- ((1/3) * s.prob) + ((2/3) * g.prob)
return(w.prob)
}
team.replace <- function(team.code) {
# team.code = vector of 3-letter team codes
# return vector replacing LAK, NJD, SJS, and TBL with L.A, N.J, S.J, and T.B
new.code <- ifelse(team.code == "LAK", "L.A",
ifelse(team.code == "NJD", "N.J",
ifelse(team.code == "SJS", "S.J",
ifelse(team.code == "TBL", "T.B", team.code))))
return(new.code)
}
get.eval.times <- function(g.json) {
# g.json = JSON file for a given game
# return data frame of information at goalie evaluation times (period ends and all goals)
g.id <- g.json[["gameData"]][["game"]][["pk"]]
game.year <- g.id %/% (1e6)
game.id <- g.id %% (1e6)
h.team <- g.json[["gameData"]][["teams"]][["home"]][["triCode"]]
a.team <- g.json[["gameData"]][["teams"]][["away"]][["triCode"]]
e.times <- data.frame(season = season,
game_id = game.id,
home.team = h.team,
away.team = a.team,
team = g.json[["liveData"]][["plays"]][["allPlays"]][["team"]][["triCode"]],
event = g.json[["liveData"]][["plays"]][["allPlays"]][["result"]][["event"]],
goals = g.json[["liveData"]][["plays"]][["allPlays"]][["about"]][["goals"]],
period = g.json[["liveData"]][["plays"]][["allPlays"]][["about"]][["period"]],
time = g.json[["liveData"]][["plays"]][["allPlays"]][["about"]][["periodTimeRemaining"]])
eval.times <- e.times %>%
filter(event %in% c("Goal", "Shot", "Game Scheduled", "Period End")) %>%
filter(period <= 3) %>%
mutate(home.shot = as.numeric(event != "Game Scheduled" &
event != "Period End" &
as.character(team) == as.character(home.team)),
away.shot = as.numeric(event != "Game Scheduled" &
event != "Period End" &
as.character(team) == as.character(away.team)),
time = (60 * 20 * period) - as.numeric(seconds(ms(time)))) %>%
group_by(season, game_id, home.team, away.team) %>%
summarise(time = time,
event = event,
home.goals = goals.home,
away.goals = goals.away,
home.shots = cumsum(home.shot),
away.shots = cumsum(away.shot),
.groups = "drop") %>%
filter(event != "Shot") %>%
select(-event) %>%
mutate(d.score = home.goals - away.goals,
home.team = team.replace(as.character(home.team)),
away.team = team.replace(as.character(away.team)))
return(eval.times)
}
get.win.probs <- function(eval.times, nb.fit, A1, A2, B1, B2) {
# eval.times = data frame of goalie evaluation times for a single game
# nb.fit = negative binomial fit on today's prior shots
# A1, A2, B1, B2 = save probability information from today's prior shots
# return updated data frame for game with win probabilities
h.team <- unique(eval.times["home.team"])
a.team <- unique(eval.times["away.team"])
home <- c("Home", "Away")
team <- unname(unlist(c(h.team, a.team)))
r <- nb.fit$theta
p <- predict(nb.fit, data.frame(team = team, home = home), type = "response")
p <- r / (r + p)
r <- r/60
both.starters <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], as.numeric(x[7]),
as.numeric(x[9]) - as.numeric(x[7]),
A2, B2, p[2], as.numeric(x[6]),
as.numeric(x[8]) - as.numeric(x[6]),
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
home.backup <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], 0, 0,
A2, B2, p[2], as.numeric(x[6]),
as.numeric(x[8]) - as.numeric(x[6]),
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
away.backup <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], as.numeric(x[7]),
as.numeric(x[9]) - as.numeric(x[7]),
A2, B2, p[2], 0, 0,
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
both.backups <- apply(eval.times, MARGIN = 1,
function(x) s.win.prob.t(A1, B1, p[1], 0, 0,
A2, B2, p[2], 0, 0,
(3600 - as.numeric(x[5]))/60,
r, as.numeric(x[10])))
wp.recs <- tibble(eval.times,
both.starters = both.starters,
home.backup = home.backup,
away.backup = away.backup,
both.backups = both.backups) %>%
mutate(d.wp.home = home.backup - both.starters,
d.wp.away = (1 - away.backup) - (1 - both.starters),
home.rec = ifelse(d.wp.home > 0, "Pull", "Keep"),
away.rec = ifelse(d.wp.away > 0, "Pull", "Keep")) %>%
filter(time > 0 & time < 3600)
return(wp.recs)
}
rec.output <- function(wp.recs) {
# wp.recs = full data frame of recommendation information
# return smaller data frame that outputs necessary information
return(select(wp.recs,
home.team, away.team, time, home.goals, away.goals, both.starters,
d.wp.home, d.wp.away, home.rec, away.rec))
}
today.games <- fromJSON("https://statsapi.web.nhl.com/api/v1/schedule")
live.games <- data.frame(game_id = today.games[["dates"]][["games"]][[1]][["gamePk"]],
status = today.games[["dates"]][["games"]][[1]][["status"]][["detailedState"]]) %>%
filter(grepl("In Progress", status)) %>%
select(game_id) %>%
unlist()
game.link <- paste("https://statsapi.web.nhl.com/api/v1/game/",
live.games,
"/feed/live?site=en_nhl", sep = "")
g.json <- lapply(game.link, fromJSON)
eval.times <- lapply(g.json, get.eval.times)
# prior data
prior.shots <- filter(shot.data, season == 2020)
nb.fit <- glm.nb(shots ~ team + home, data = prior.shots)
svp <- prior.shots$st.svp.adj
beta.params <- beta.mom(mean(svp), var(svp))
beta.mle <- fitdistr(svp, "beta", start = list(shape1 = beta.params[1], shape2 = beta.params[2]),
lower = c(0, 0))
svp.A <- beta.mle$estimate[2]
svp.B <- beta.mle$estimate[1]
A1 <- svp.A
A2 <- svp.A
B1 <- svp.B
B2 <- svp.B
wp.recs <- lapply(eval.times, function(x) get.win.probs(x, nb.fit, A1, A2, B1, B2))
lapply(wp.recs, rec.output)
